I will implement the sticky detection and scroll locking mechanism by refactoring `CitySelector` and its sub-components.

### 1. Refactor `CitySelector` for Sticky Detection
- **Objective**: Detect when the `.adm-tabs-header` becomes sticky (reaches `top: 0`).
- **Implementation**:
  - Add a scroll listener to the main scroll container (`.city-selector-body`).
  - Calculate the `scrollTop` position relative to the `Tabs` header offset.
  - Maintain a `isSticky` state.
  - When `scrollTop` >= `headerOffset` (where headerOffset is roughly the height of `LocationStatus` + `HistorySection` + `header-divider`), set `isSticky = true`.
  - Pass `isSticky` down to children tabs via context or props.

### 2. Implement Scroll Locking in Tabs
- **Objective**: Prevent inner content from scrolling unless `isSticky` is true.
- **DomesticTab**:
  - Pass `isSticky` prop.
  - In `CityIndexList`, apply `overflow-y: hidden` (or pointer-events control) when `!isSticky`.
  - Actually, a better approach for `DomesticTab` (which uses `CityIndexList`'s own scroll logic) is to disable its internal scroll listener or set `touch-action: none` on the list container when not sticky.
- **OverseasTab**:
  - Pass `isSticky` prop.
  - In `OverseasTab`, update `.content-container` style: `overflow-y: isSticky ? 'auto' : 'hidden'`.

### 3. Nested Scroll Coordination
- **Problem**: If the inner content is locked, the user's swipe should scroll the outer container (`.city-selector-body`) instead.
- **Solution**:
  - By default, if the inner container has `overflow: hidden`, the scroll event naturally bubbles up to the parent (`.city-selector-body`), so the parent scrolls.
  - Once `isSticky` becomes true, we enable `overflow-y: auto` on the inner container.
  - **Critical Edge Case**: When scrolling back up. If inner content is scrolled down (`scrollTop > 0`), we want to scroll inner content up. If inner content reaches top (`scrollTop === 0`), we want to unstick the header and scroll the outer container up.
  - **Refinement**:
    - Outer container (`.city-selector-body`) handles the initial scroll.
    - When sticky threshold is reached, `isSticky` turns on.
    - Inner container (`OverseasTab .content-container`) gets `overflow-y: auto`.
    - To allow scrolling back *up* from the sticky state to non-sticky:
      - We need to ensure that when inner content is at top, the outer container can take over.
      - Standard nested scrolling behavior usually handles this, but we might need `overscroll-behavior: contain` or similar logic if smooth transition is tricky.
      - A simpler logic:
        - `CitySelector` listens to scroll. If `scrollTop < threshold`, `isSticky = false`.
        - `OverseasTab`: If `!isSticky`, `overflow-y: hidden`. If `isSticky`, `overflow-y: auto`.

### 4. Implementation Details
- **File**: `d:\Hotel_Booking_Platform\src\components\CitySelector\index.tsx`
  - Add `onScroll` handler to `.city-selector-body`.
  - Use `useThrottleFn` for scroll performance.
  - Calculate threshold dynamically using `useRef` on the `Tabs` component or a wrapper div around it.
- **File**: `d:\Hotel_Booking_Platform\src\components\CitySelector\components\TabContent\OverseasTab\index.tsx`
  - Accept `scrollEnabled` prop.
  - Apply style `overflowY: scrollEnabled ? 'auto' : 'hidden'` to `.content-container`.
- **File**: `d:\Hotel_Booking_Platform\src\components\CitySelector\components\TabContent\DomesticTab\index.tsx`
  - Accept `scrollEnabled` prop.
  - Pass to `CityIndexList`.

### 5. Verification
- Verify that initially, swiping on the tab content scrolls the whole page up until the tab header hits the top.
- Verify that once sticky, swiping on the tab content scrolls the content itself.
- Verify that swiping down when content is at top un-sticks the header (scrolls the page down).
